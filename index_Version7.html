<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>pong ping</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
/* (estilos idénticos a la versión anterior) */
:root{
  --bg:#0b0f17;
  --panel:#0f1720;
  --accent:#ffd166;
  --muted:#9aa6b2;
  --white: #ffffff;
  --glass: rgba(255,255,255,0.04);
}
html, body {
  height: 100%;
  margin: 0;
  background: linear-gradient(180deg, #071025 0%, #05060a 100%), var(--bg);
  color: var(--white);
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  -webkit-font-smoothing: antialiased;
  display:flex;
  align-items:center;
  justify-content:center;
}
.wrap {
  width: 960px;
  max-width: 96%;
  margin: 28px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:12px;
}

.hud {
  width:100%;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.scoreboard {
  display:flex;
  gap:18px;
  align-items:center;
  justify-content:center;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  padding:10px 14px;
  border-radius:12px;
  box-shadow: 0 6px 24px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
}

.score-box {
  text-align:center;
  min-width:120px;
  padding:6px 10px;
  border-radius:8px;
  background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
}
.score-box .name {
  font-size:13px;
  color:var(--muted);
  margin-bottom:4px;
}
.score-box .score {
  font-weight:700;
  font-size:34px;
  color:var(--white);
  letter-spacing:2px;
}

.controls {
  display:flex;
  align-items:center;
  gap:10px;
}
button {
  background: var(--accent);
  border: none;
  color: #111;
  padding:8px 14px;
  font-weight:700;
  border-radius:8px;
  cursor:pointer;
  box-shadow: 0 6px 18px rgba(255,209,102,0.12);
}
button.ghost {
  background: transparent;
  color: var(--muted);
  border: 1px solid rgba(255,255,255,0.04);
  box-shadow: none;
}

.panel {
  width:100%;
  display:flex;
  flex-direction:column;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  padding:12px;
  border-radius:14px;
}

.container {
  display:flex;
  align-items:center;
  justify-content:center;
}

canvas {
  display:block;
  border-radius:10px;
  background: radial-gradient(circle at 20% 10%, rgba(255,255,255,0.02), transparent 10%), rgba(0,0,0,0.9);
  box-shadow: 0 18px 60px rgba(2,6,23,0.7);
  max-width:100%;
}

.meta {
  margin-top:8px;
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  color:var(--muted);
  font-size:13px;
}
.meta .indicators {
  display:flex;
  gap:16px;
  align-items:center;
}

/* Pantalla d'inici */
#startScreen {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.7));
  z-index: 20;
  flex-direction: column;
  gap: 18px;
  border-radius:10px;
}
#startScreen h1 {
  font-size: 48px;
  margin: 0;
  letter-spacing: 2px;
  color: var(--accent);
  text-shadow: 0 6px 26px rgba(255,209,102,0.12);
}
#startScreen p {
  margin: 0;
  color: var(--muted);
}
#overlayWrap { position:relative; width:100%; display:flex; justify-content:center; }

@media (max-width:700px){
  .wrap { width:100%; margin:12px; }
  .score-box .score { font-size:28px; }
  #startScreen h1 { font-size:36px; }
}
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="scoreboard" role="status" aria-live="polite">
      <div class="score-box">
        <div class="name">Jugador</div>
        <div class="score" id="playerScore">0</div>
      </div>

      <div class="controls">
        <button id="startBtn">Iniciar</button>
        <button id="resetBtn" class="ghost">Reiniciar</button>
      </div>

      <div class="score-box">
        <div class="name">IA</div>
        <div class="score" id="aiScore">0</div>
      </div>
    </div>

    <div style="margin-left:auto;color:var(--muted);font-size:13px;">Primer a 10 punts</div>
  </div>

  <div class="panel">
    <div class="container" id="overlayWrap" style="position:relative">
      <canvas id="game" width="900" height="600"></canvas>

      <div id="startScreen" aria-hidden="false">
        <h1>pong ping</h1>
        <p>Pulsa "Iniciar" para entrar</p>
        <button id="startBtnOverlay">Iniciar</button>
      </div>
    </div>

    <div class="meta">
      <div class="indicators">
        <div id="speedBall">Vel bola: 0</div>
        <div id="speedPaddle">Vel palas: 0</div>
        <div id="iaFollow">IA follow: 0</div>
      </div>
      <div style="color:var(--muted)">Controles: flechas ↑ ↓ (también touch)</div>
    </div>
  </div>
</div>

<script>
/* Juego Pong mejorado: marcador fuera del canvas, estética arreglada y velocidad del jugador reducida.
   Cambios: Pala jugador en azul, pala IA en rojo.
*/

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const playerScoreEl = document.getElementById("playerScore");
const aiScoreEl = document.getElementById("aiScore");
const speedBallEl = document.getElementById("speedBall");
const speedPaddleEl = document.getElementById("speedPaddle");
const iaFollowEl = document.getElementById("iaFollow");

const startBtn = document.getElementById("startBtn");
const startBtnOverlay = document.getElementById("startBtnOverlay");
const resetBtn = document.getElementById("resetBtn");
const startScreen = document.getElementById("startScreen");

const paddleHeight = 90;
const paddleWidth = 12;
let playerY = canvas.height / 2 - paddleHeight / 2;
let aiY = playerY;

const ballRadius = 9;
let ballX = canvas.width / 2;
let ballY = canvas.height / 2;

const initialBallSpeedX = 4;
const initialBallSpeedY = 3;
let ballSpeedX = initialBallSpeedX * (Math.random() > 0.5 ? 1 : -1);
let ballSpeedY = initialBallSpeedY * (Math.random() > 0.5 ? 1 : -1);

let playerScore = 0;
let aiScore = 0;
const winningScore = 10;

/* Cambios solicitados: disminuir velocidad del jugador.
   Base reducida y factor más suave para que la pala del jugador no sea demasiado rápida.
*/
const basePaddleSpeed = 3.0;      // reducido (antes 6)
const maxPaddleSpeedAbsolute = 14;
const paddleSpeedFactor = 0.8;    // dependencia con velocidad de la bola
const paddleSpeedIncreasePerHit = 0.45; // bonus acumulado por impactos
let paddleSpeedBonusFromHits = 0;

// IA
const baseAiFollow = 0.45;
const aiFollowBallFactor = 0.045;
const maxAiFollow = 1.0;
let aiFollowBonusFromHits = 0;

// Pelota aumenta velocidad por impacto
const speedIncreasePerHit = 1.06;
const maxBallSpeed = 16;

let keysDown = {};
let touching = false;

// Evitar que las flechas desplacen la página
window.addEventListener("keydown", (e) => {
  if (e.key === "ArrowUp" || e.key === "ArrowDown") e.preventDefault();
});

// Flags de teclado
window.addEventListener("keydown", (e) => {
  if (e.key === "ArrowUp") keysDown["ArrowUp"] = true;
  else if (e.key === "ArrowDown") keysDown["ArrowDown"] = true;
});
window.addEventListener("keyup", (e) => {
  if (e.key === "ArrowUp") keysDown["ArrowUp"] = false;
  else if (e.key === "ArrowDown") keysDown["ArrowDown"] = false;
});

// Touch controls (mueve la pala a la posición del dedo)
canvas.addEventListener("touchstart", (e) => { touching = true; handleTouch(e); }, {passive: true});
canvas.addEventListener("touchmove", (e) => { if (touching) handleTouch(e); }, {passive: true});
canvas.addEventListener("touchend", () => { touching = false; });

function handleTouch(e){
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  if (!touch) return;
  playerY = touch.clientY - rect.top - paddleHeight/2;
  playerY = clampPaddleY(playerY);
}

function clampPaddleY(y) { return Math.max(0, Math.min(y, canvas.height - paddleHeight)); }

function resetAll(){
  playerScore = 0;
  aiScore = 0;
  paddleSpeedBonusFromHits = 0;
  aiFollowBonusFromHits = 0;
  playerY = canvas.height/2 - paddleHeight/2;
  aiY = playerY;
  resetBall(Math.random()>0.5?1:-1);
  updateHUD();
}

function resetBall(direction){
  ballX = canvas.width / 2;
  ballY = canvas.height / 2;
  ballSpeedX = initialBallSpeedX * (direction || (Math.random()>0.5?1:-1));
  ballSpeedY = initialBallSpeedY * (Math.random()>0.5?1:-1);
  aiFollowBonusFromHits = 0;
  paddleSpeedBonusFromHits = 0;

  if (playerScore >= winningScore || aiScore >= winningScore) {
    setTimeout(()=> {
      playerScore = 0; aiScore = 0;
      paddleSpeedBonusFromHits = 0; aiFollowBonusFromHits = 0;
      playerY = canvas.height/2 - paddleHeight/2;
      aiY = playerY;
      updateHUD();
    }, 700);
  }
}

let rafId = null;
let gameStarted = false;
function startGame(){
  resetAll();
  gameStarted = true;
  startScreen.style.display = "none";
  startScreen.setAttribute("aria-hidden","true");
  if (!rafId) rafId = requestAnimationFrame(gameLoop);
}

function stopGame(){
  if (rafId){ cancelAnimationFrame(rafId); rafId = null; }
  gameStarted = false;
}

startBtn.addEventListener("click", startGame);
startBtnOverlay.addEventListener("click", startGame);
resetBtn.addEventListener("click", ()=>{ resetAll(); startScreen.style.display = "flex"; startScreen.setAttribute("aria-hidden","false"); stopGame(); });

function update(){
  if (!gameStarted) return;

  ballX += ballSpeedX;
  ballY += ballSpeedY;

  // velocidad de la bola actual
  const ballSpeed = Math.hypot(ballSpeedX, ballSpeedY);

  // velocidad máxima de las palas depende de la velocidad de la bola, con el bonus por impactos
  let computedPaddleMaxSpeed = basePaddleSpeed + paddleSpeedFactor * ballSpeed + paddleSpeedBonusFromHits;
  computedPaddleMaxSpeed = Math.min(maxPaddleSpeedAbsolute, Math.max(basePaddleSpeed, computedPaddleMaxSpeed));

  // reactividad IA combinada
  let computedAiFollow = baseAiFollow + aiFollowBallFactor * ballSpeed + aiFollowBonusFromHits;
  computedAiFollow = Math.min(maxAiFollow, Math.max(0.05, computedAiFollow));

  // movimiento jugador (flechitas)
  if (!touching) {
    let vy = 0;
    if (keysDown["ArrowUp"] && !keysDown["ArrowDown"]) vy = -computedPaddleMaxSpeed;
    else if (keysDown["ArrowDown"] && !keysDown["ArrowUp"]) vy = computedPaddleMaxSpeed;
    playerY += vy;
    playerY = clampPaddleY(playerY);
  }

  // rebot vertical
  if (ballY - ballRadius <= 0) { ballY = ballRadius; ballSpeedY *= -1; }
  else if (ballY + ballRadius >= canvas.height) { ballY = canvas.height - ballRadius; ballSpeedY *= -1; }

  // colisión jugador (izquierda)
  if (ballX - ballRadius <= paddleWidth) {
    if (ballY >= playerY && ballY <= playerY + paddleHeight) {
      ballX = paddleWidth + ballRadius;
      const relativeIntersectY = (playerY + paddleHeight/2) - ballY;
      const normalized = relativeIntersectY / (paddleHeight/2);
      const bounceAngle = normalized * (Math.PI / 4);
      const speed = Math.hypot(ballSpeedX, ballSpeedY);
      ballSpeedX = Math.abs(speed * Math.cos(bounceAngle));
      ballSpeedY = -speed * Math.sin(bounceAngle);
      // incrementar velocidad de bola y limitar
      ballSpeedX *= speedIncreasePerHit;
      ballSpeedY *= speedIncreasePerHit;
      limitBallSpeed();
      // aumentar bonus palas y reactividad IA
      paddleSpeedBonusFromHits = Math.min(maxPaddleSpeedAbsolute, paddleSpeedBonusFromHits + paddleSpeedIncreasePerHit);
      aiFollowBonusFromHits = Math.min(maxAiFollow, aiFollowBonusFromHits + 0.03);
    }
  }

  // IA se mueve calculando desplazamiento deseado luego limitando a computedPaddleMaxSpeed
  {
    const aiCenter = aiY + paddleHeight/2;
    const diff = ballY - aiCenter;
    const desiredMove = diff * computedAiFollow;
    let move = Math.max(-computedPaddleMaxSpeed, Math.min(computedPaddleMaxSpeed, desiredMove));
    aiY += move;
    aiY = clampPaddleY(aiY);
  }

  // colisión IA (derecha)
  if (ballX + ballRadius >= canvas.width - paddleWidth) {
    if (ballY >= aiY && ballY <= aiY + paddleHeight) {
      ballX = canvas.width - paddleWidth - ballRadius;
      const relativeIntersectY = (aiY + paddleHeight/2) - ballY;
      const normalized = relativeIntersectY / (paddleHeight/2);
      const bounceAngle = normalized * (Math.PI / 4);
      const speed = Math.hypot(ballSpeedX, ballSpeedY);
      ballSpeedX = -Math.abs(speed * Math.cos(bounceAngle));
      ballSpeedY = -speed * Math.sin(bounceAngle);
      ballSpeedX *= speedIncreasePerHit;
      ballSpeedY *= speedIncreasePerHit;
      limitBallSpeed();
      paddleSpeedBonusFromHits = Math.min(maxPaddleSpeedAbsolute, paddleSpeedBonusFromHits + paddleSpeedIncreasePerHit);
      aiFollowBonusFromHits = Math.min(maxAiFollow, aiFollowBonusFromHits + 0.03);
    }
  }

  // punto marcado
  if (ballX + ballRadius < 0) { aiScore += 1; resetBall(-1); updateHUD(); }
  else if (ballX - ballRadius > canvas.width) { playerScore += 1; resetBall(1); updateHUD(); }

  // actualizar valores mostrados
  lastComputedPaddleSpeed = computedPaddleMaxSpeed;
  lastComputedAiFollow = computedAiFollow;
}

function limitBallSpeed(){
  const cur = Math.hypot(ballSpeedX, ballSpeedY);
  if (cur > maxBallSpeed){
    const scale = maxBallSpeed / cur;
    ballSpeedX *= scale; ballSpeedY *= scale;
  }
}

/* Dibujo: palas redondeadas, línea central punteada, bola con gradiente y sombra.
   El marcador ahora está fuera del canvas (DOM) y se actualiza con updateHUD().
   Pala jugador: azul. Pala IA: roja.
*/
function draw(){
  // fondo
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // línea central punteada
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 4;
  ctx.setLineDash([12,12]);
  ctx.beginPath();
  ctx.moveTo(canvas.width/2, 6);
  ctx.lineTo(canvas.width/2, canvas.height-6);
  ctx.stroke();
  ctx.restore();

  // palas (rounded rect) -- jugador azul, IA rojo
  drawRoundedPaddle(0, playerY, paddleWidth, paddleHeight, 6, "#2D86FF", "rgba(45,134,255,0.15)"); // azul jugador
  drawRoundedPaddle(canvas.width - paddleWidth, aiY, paddleWidth, paddleHeight, 6, "#FF4C4C", "rgba(255,76,76,0.12)"); // rojo IA

  // bola (círculo con gradiente y sombra)
  ctx.save();
  ctx.beginPath();
  ctx.shadowColor = "rgba(0,0,0,0.6)";
  ctx.shadowBlur = 10;
  const grad = ctx.createRadialGradient(ballX - ballRadius/3, ballY - ballRadius/3, 1, ballX, ballY, ballRadius);
  grad.addColorStop(0, "rgba(255,255,255,0.95)");
  grad.addColorStop(0.6, "rgba(255,220,80,0.95)");
  grad.addColorStop(1, "rgba(200,120,0,0.8)");
  ctx.fillStyle = grad;
  ctx.arc(ballX, ballY, ballRadius, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* Dibuja un rectángulo redondeado con borde suave para la pala */
function drawRoundedPaddle(x,y,w,h,r, fill, glow){
  ctx.save();
  // sombra sutil del color de la pala
  ctx.shadowColor = glow || "rgba(0,0,0,0.5)";
  ctx.shadowBlur = 10;
  ctx.fillStyle = fill;
  roundRect(ctx, x, y, w, h, r);
  ctx.fill();
  // borde interior (sutil)
  ctx.shadowBlur = 0;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.stroke();
  ctx.restore();
}

function roundRect(ctx, x, y, width, height, radius) {
  radius = Math.min(radius, width/2, height/2);
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + width, y, x + width, y + height, radius);
  ctx.arcTo(x + width, y + height, x, y + height, radius);
  ctx.arcTo(x, y + height, x, y, radius);
  ctx.arcTo(x, y, x + width, y, radius);
  ctx.closePath();
}

// HUD DOM updates
let lastComputedPaddleSpeed = basePaddleSpeed;
let lastComputedAiFollow = baseAiFollow;
function updateHUD(){
  playerScoreEl.innerText = playerScore;
  aiScoreEl.innerText = aiScore;
  speedBallEl.innerText = "Vel bola: " + (Math.round(Math.hypot(ballSpeedX, ballSpeedY)*10)/10);
  speedPaddleEl.innerText = "Vel palas: " + (Math.round(lastComputedPaddleSpeed*10)/10);
  iaFollowEl.innerText = "IA follow: " + (Math.round(lastComputedAiFollow*1000)/1000);
}

function gameLoop(){
  update();
  draw();
  updateHUD();
  rafId = requestAnimationFrame(gameLoop);
}

// No empieza automaticamente: esperar a que pulse "Iniciar".
</script>
</body>
</html>